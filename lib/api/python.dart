// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'python.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `prepare_dict`, `to_py_object`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// 手动初始化 Python 环境
/// 参数由 Dart 端传入，更加灵活
void initPyEnv(
        {required String pythonHome,
        required String libPath,
        required String sitePackages}) =>
    RustLib.instance.api.crateApiPythonInitPyEnv(
        pythonHome: pythonHome, libPath: libPath, sitePackages: sitePackages);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PyModuleWrapper>>
abstract class PyModuleWrapper implements RustOpaqueInterface {
  String asStr();

  String callFunction({required String funcName});

  String callFunctionArgs(
      {required String funcName, required List<PyArgument> args});

  static PyModuleWrapper importModule({required String moduleName}) =>
      RustLib.instance.api
          .crateApiPythonPyModuleWrapperImportModule(moduleName: moduleName);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PyObjectWrapper>>
abstract class PyObjectWrapper implements RustOpaqueInterface {
  /// 尝试转换成 bool
  bool asBool();

  /// 尝试转换成 f64
  double asFloat();

  /// 尝试转换成 i64
  PlatformInt64 asInt();

  /// 尝试将 List 转换为 Vec<String> (用于 Dart)
  Future<List<String>> asListString();

  /// 对应 Python: repr(self)
  String asRepr();

  /// 对应 Python: str(self)
  String asStr();

  /// 调用对象 (如果它是函数或类)
  /// Python: self(*args)
  Future<PyObjectWrapper> call({required List<PyArgument> args});

  /// 调用对象的方法
  /// Python: self.method_name(*args)
  Future<PyObjectWrapper> callMethod(
      {required String methodName, required List<PyArgument> args});

  /// 字典/列表获取项
  /// Python: self[key]
  PyObjectWrapper getItem({required PyArgument key});

  /// 获取属性，返回新的对象句柄
  /// Python: self.attr_name
  PyObjectWrapper getattr({required String attrName});

  /// 检查属性是否存在
  /// Python: hasattr(self, attr_name)
  bool hasattr({required String attrName});

  bool isCallable();

  /// 检查是否为空
  bool isEmpty();

  bool isNone();

  /// 获取长度 (用于 List, Dict, Str, Set 等)
  /// Python: len(self)
  BigInt len();

  /// 字典/列表设置项
  /// Python: self[key] = value
  void setItem({required PyArgument key, required PyArgument value});

  /// 设置属性
  /// Python: self.attr_name = value
  void setattr({required String attrName, required PyArgument value});
}

@freezed
sealed class PyArgument with _$PyArgument {
  const PyArgument._();

  const factory PyArgument.str(
    String field0,
  ) = PyArgument_Str;
  const factory PyArgument.int(
    PlatformInt64 field0,
  ) = PyArgument_Int;
  const factory PyArgument.float(
    double field0,
  ) = PyArgument_Float;
  const factory PyArgument.bool(
    bool field0,
  ) = PyArgument_Bool;
  const factory PyArgument.listStr(
    List<String> field0,
  ) = PyArgument_ListStr;
  const factory PyArgument.listInt(
    Int64List field0,
  ) = PyArgument_ListInt;
}

class PythonUtility {
  const PythonUtility();

  /// 执行 Python 表达式，支持自定义 globals 和 locals 上下文
  ///
  /// - `code`: Python 代码
  /// - `globals`: 全局变量。传 None 则使用默认 __main__，传 [] 则创建纯净沙盒。
  /// - `locals`: 局部变量。传 None 则默认与 globals 相同。
  /// - `imports`: 需要预先导入的模块，会自动注入到上下文。
  static Future<String> eval(
          {required String code,
          List<(String, PyArgument)>? globals,
          List<(String, PyArgument)>? locals,
          required List<String> imports}) =>
      RustLib.instance.api.crateApiPythonPythonUtilityEval(
          code: code, globals: globals, locals: locals, imports: imports);

  /// 计算表达式并返回一个通用对象句柄 (PyObjectWrapper)
  /// 这允许 Dart 持有这个对象，并在随后调用它的方法
  static Future<PyObjectWrapper> evalAsObject(
          {required String code,
          List<(String, PyArgument)>? globals,
          List<(String, PyArgument)>? locals}) =>
      RustLib.instance.api.crateApiPythonPythonUtilityEvalAsObject(
          code: code, globals: globals, locals: locals);

  /// 执行 Python 代码片段（无返回值）
  /// 适用于 import, class 定义, def 函数定义等
  static Future<void> execute(
          {required String code,
          List<(String, PyArgument)>? globals,
          List<(String, PyArgument)>? locals}) =>
      RustLib.instance.api.crateApiPythonPythonUtilityExecute(
          code: code, globals: globals, locals: locals);

  /// 获取模块的属性
  /// - `module_name`: 模块名称
  /// - `attr_name`: 属性名称
  static Future<String> getModuleAttr(
          {required String moduleName, required String attrName}) =>
      RustLib.instance.api.crateApiPythonPythonUtilityGetModuleAttr(
          moduleName: moduleName, attrName: attrName);

  /// 运行一个 Python 脚本文件
  static Future<void> runFile({required String filePath}) =>
      RustLib.instance.api
          .crateApiPythonPythonUtilityRunFile(filePath: filePath);

  /// 设置模块的属性
  /// 对应 Python: module.attr = value
  static Future<void> setModuleAttr(
          {required String moduleName,
          required String attrName,
          required PyArgument value}) =>
      RustLib.instance.api.crateApiPythonPythonUtilitySetModuleAttr(
          moduleName: moduleName, attrName: attrName, value: value);

  @override
  int get hashCode => 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PythonUtility && runtimeType == other.runtimeType;
}
